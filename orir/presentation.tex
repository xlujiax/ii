\documentclass{beamer}
\usetheme{Antibes}
\usecolortheme{seagull}
\setbeamertemplate{footline}{\hfill\insertframenumber/\inserttotalframenumber\hspace*{.5cm}}
\setbeamertemplate{navigation symbols}{}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{hyperref}
\usepackage{rotating}
\usepackage{listings}

\title{Obliczenia równoległe i rozproszone}
\author{Maciej Pacut}
\date{Luty 2012}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Layout}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \tableofcontents[allowframebreaks]
\end{frame}

\section{Wstęp}
\begin{frame}{Temat prezentacji}
  A. Karbowski, Programowanie równoległe i rozproszone

  Rozdziały 1,2,3
\end{frame}
\section{Rozdział 1}

\begin{frame}{Zalety obliczeń równoległych}
  \begin{enumerate}[<+->]
  \item przyspieszenie czasu przeprowadzania obliczeń
  \item zwiększenie niezawodności obliczeń
  \item stworzenie możliwości rozwiązania zadań zbyt dużych dla maszyny sekwencyjnej
  \item umożliwienie wykorzystania pełnej mocy obliczeniowej procesorów wielordzeniowych
  \end{enumerate}
\end{frame}

\begin{frame}{Podstawowe pojęcia}
  \begin{enumerate}
  \item Obliczenia współbieżne - następne zadanie rozpoczyna się zanim skończy się poprzednie (mogą być przeprowadzane na jednym procesorze z podziałem czasu)
  \item Obliczenia równoległe - obliczenia współbieżne na wielu procesorach
  \item Obliczenia rozproszone - obliczenia bez dzielonej pamięci (przekazywanie komunikatów)
  \end{enumerate}
\end{frame}

\begin{frame}{Przykłady problemów, których rozwiązanie jest możliwe tylko za pomocą algorytmów rozproszonych}
  \begin{enumerate}
  \item Prognoza pogody - dwa dni po
  \item Dane z teleskopów
  \end{enumerate}
\end{frame}

\section{Rozdział 2}

\begin{frame}{Prawo Amdahla}
  \begin{enumerate}
  \item Mówi o ograniczeniu górnym przyspieszenia wykonywania zadania przy przenoszeniu z procesora sekwencyjnego na wieloprocesory
  \item Wzorek, opis zmiennych i funkcji
  \end{enumerate}
\end{frame}
\section{Rozdział 3}


\begin{frame}{Procesory wielordzeniowe}
  \begin{enumerate}
  \item wiele jednostek obliczeniowych dzielących magistralę
  \item czasami też L2 cache
  \end{enumerate}
\end{frame}

\begin{frame}{Hyper Threading}
  \begin{enumerate}
  \item wolne cykle (czekanie na IO)
  \item dwa wątki na procesorze jednordzeniowym z powodu dużej liczby wolnych cykli
  \item wątki są przełączane
  \end{enumerate}
\end{frame}

\begin{frame}{Rozszerzenia strumieniowe}
  \begin{enumerate}
  \item realizacja podstawowych operacji arytmetycznych na wektorze w sposób równoległy
  \item dodatkowe jendostki przeznaczone tylko do tej pracy
  \end{enumerate}
\end{frame}

\begin{frame}{Obliczenia na kartach graficznych}
  \begin{enumerate}
  \item kary graficzne maja wiele jednostek przetwarzajacych dane (nawet kilkaset)
  \item jest to konsekwencją [w dużej mierze] równoległej natury procesu wyświetlania grafiki
  \item kiedyś potok graficzny był nieprogramowalny - algorytmy do przetwarzania wierzchołków/pikseli były zapisane w sprzęcie
  \end{enumerate}
\end{frame}

\begin{frame}{Obliczenia na kartach graficznych 2}
  \begin{enumerate}
  \item jednostki przetwarzania ogólnego zastosowania
  \item pojawienie się shaderów
  \item koniec stałego potoku graficznego
  \item GPGPU - General Purpose Computing on Graphics Procesing Units
  \item Tesla - nVidia, FireStream - AMD
  \end{enumerate}
\end{frame}

\begin{frame}{Hybrydyzacja obliczeń}
  \begin{enumerate}
  \item czyli korzystanie z różnorodnych jednostek wykonawczych
  \item różne reprezentacje typów danych (endianness: PowerPC - big, x86 - little)
  \item różne precyzje typów danych (halves/partials na GPU to liczby zmiennoprzecinkowe 16-bitowe, są też 32-bitowe)
  \item IBM Roadrunner - kilkanaście tysięcy procesorów AMD (2 rdzenie, x86) i tyle samo procesorów z Playstation 3 (1 rdzeń PowerPC, 8 rdzeni do obliczeń wektorowych)
  \end{enumerate}
\end{frame}

\begin{frame}{Krótko o superkomputerach}
  \begin{enumerate}
  \item Najczęściej są to połączone procesory spotykane w komputerach osobistych
  \item Klastry wieloprocesorów (wspólna pamięć) połączone szybkimi sieciami wewnętrznymi
  \item Coraz rzadziej wykorzystuje się procesory dedykowane do obliczeń wektorowych
  \end{enumerate}
\end{frame}

\section{Klasyfikacja maszyn równoległych}

\begin{frame}{Klasyfikacja maszyn równoległych wg Flynna}
  \begin{enumerate}
  \item SISD - klasyczna maszyna sekwencyjna
  \item SIMD - procesory wektorowe, procesory z jednostkami wktorowymi
  \item MISD - tylko specyficzne zastosowania
  \item MIMD - równoległa praca na wielu różnych danych
  \end{enumerate}
\end{frame}

\begin{frame}{Klasyfikacja maszyn równoległych ze względu na rodzaj pamięci}
  \begin{enumerate}
  \item Pamięć dzielona - wspólna przestrzeń adresowa
  \item Pamięć lokalna - należy samemu podzielić dane
  \end{enumerate}
\end{frame}

\begin{frame}{Równoległość w maszynach typu SISD}
  \begin{enumerate}
  \item Przetwarzanie potokowe - kilka taktów na instrukcję (pobranie rozkazu, jego argumentów, operacje arytmetyczne, zapis, ...); w momencie zwolnienia fragmentu procesora rozpoczynane jest wykonywanie następnej instrukcji
  \item Rozszerzenia strumieniowe - nowe rozkazy procesora wykonujące obliczenia równoległe na danych mniejszej precyzji (przykłady: MMX, SSE$\{\epsilon,2,3\}$, AltiVec, 3DNow!)
  \item Hyper Threading - dwa wątki na procesor przełączane przy oczekiwaniu na IO
  \end{enumerate}
\end{frame}

\begin{frame}{Równoległość w maszynach typu SIMD}
  \begin{enumerate}
  \item SM-SIMD
  \item DM-SIMD
  \end{enumerate}
\end{frame}

\begin{frame}{Równoległość w maszynach typu SM-SIMD}
  \begin{enumerate}
  \item Inaczej komputer wektorowy - składa się z jednego procesora wektorowego
  \item Dane zawsze są w paczkach o stałej liczności zależnej od procesora wektorowego
  \item Wykonywanie ciągów tych samych operacji
  \item Zaleta: łatwe programowanie takich maszyn
  \end{enumerate}
\end{frame}
\end{document}
